# **Product Requirements Document: The Tech Tree (Target: Elixir/Phoenix)**

*This document outlines the requirements for a future version of The Tech Tree, envisioned to be built using Elixir and the Phoenix framework.*

## **1\. Overview**

**Product Name**: **The Tech Tree**

**Description**: The Tech Tree is an adaptive learning platform designed for quick, bite-sized educational interactions, enabling professional users to rapidly acquire valuable skills. Users bookmark knowledge areas, revisit topics, and explore new technology fields in small, engaging units, powered by an AI-driven conversational learning experience built on a highly concurrent and fault-tolerant Elixir backend.

### **1.1 Motivation and Background**

In a rapidly changing technological landscape, professionals need continuous learning but often lack time and patience for lengthy traditional courses. Current learning platforms often emphasize rote memorization, leading to superficial understanding. The Tech Tree prioritizes active learning, engagement, and retention through interactive, stateful lessons managed by robust Elixir processes. The choice of Elixir/Phoenix aims to provide excellent scalability, fault tolerance, and developer productivity, leveraging its strong concurrency model and improving type safety features (Elixir 1.17+).

### **1.2 Existing Solutions**

*   Khan Academy, Coursera, Udacity, Master's programs: structured but demanding significant time.
*   The Tech Tree differentiates by providing bite-sized, adaptive, interactive lessons orchestrated by AI, focusing on real learning effectiveness and retention through active participation and conversation, built on a scalable Elixir foundation.

### **1.3 Scope**

*   Initial focus: STEM, specifically AI technologies
*   Future scope: Expand to broader professional and personal topics

### **1.4 Path to Production & AI Orchestration (Elixir Target)**

This version targets an implementation using **Elixir** and the **Phoenix Framework**. Cloud-hosted Large Language Models (LLMs) will be utilized. AI orchestration (managing onboarding, syllabus generation, lesson interactions) will be implemented using custom Elixir code, likely leveraging **OTP principles** (GenServers, Supervisors, potentially state machine libraries like `machinery`) to manage the stateful, concurrent nature of user interactions. This approach replaces the Python-specific LangGraph used in the previous iteration.

*   **Rationale:** Elixir/OTP provides a natural fit for managing potentially thousands of concurrent, stateful user lesson interactions efficiently and reliably. The improved type system (1.17+) enhances compile-time safety, addressing previous concerns with dynamic typing while maintaining high developer productivity.

## **2\. Goals and Objectives**

*(Goals remain largely the same, but the underlying technology aims to achieve them more robustly)*

### **2.1 Primary Product Goals**

*   **Low barrier, high mastery**: Bite-sized but deep, engaging learning experiences
*   **Learning Effectiveness**: Deep, confident understanding through interaction
*   **User Growth**: Organic user adoption driven by effectiveness and engagement
*   **Long-Term Monetization**: Clearly defined enterprise licensing and individual accounts

### **2.2 User Learning Goals**

*   Learners progress confidently up the tech tree
*   Continuous assessment through AI-generated quizzes and active exercises within lessons

### **2.3 Experience and Engagement Objectives**

*   Quick, potentially real-time chat-based tutorials, exercises, and quizzes integrated into lessons (leveraging Phoenix Channels/LiveView).
*   Gamification: progress indicators, badges, leaderboards.

### **2.4 Adaptivity and Personalization Goals**

*   Dynamic difficulty adjustment managed by the Elixir-based lesson interaction logic (e.g., GenServers managing lesson state) based on real-time performance and answer evaluation.
*   Custom learning paths generated by Elixir services based on user input and initial assessment.

### **2.5 Business Objectives**

*   Enterprise partnerships with dedicated onboarding and progress tracking
*   Initial technical viability within 3-4 months (Elixir rebuild), first paying users within 6-8 months.

### **2.6 Constraints**

*   Low-cost LLM models initially
*   Development team familiarizing with or skilled in Elixir/Phoenix.

---

## **3\. Target Audience & User Personas**

*(Remains the same)*

### **Primary Persona: The Upgrading Professional**

*   **Age**: 25â€“45
*   **Background**: Early- to mid-career knowledge workers
*   **Goals**: Upskill quickly for work, anticipate career changes
*   **Challenges**: Short attention spans, limited time, intimidated by formal education
*   **Preferences**: Bite-sized, active, conversational, quiz-based, gamified
*   **Technical Proficiency**: Moderate to high

---

## **4\. User Stories / Use Cases**

### **4.1 Core Learning Flow**

*   User discovers via social media/workplace recommendation
*   Registers/Logs in via the Phoenix frontend (potentially LiveView).
*   Starts with an onboarding assessment for a chosen topic, managed by an Elixir service/process.
*   Receives a personalized syllabus (Syllabus -> Module -> Lesson structure) generated or retrieved by an Elixir service.
*   Engages in interactive lessons driven by dedicated Elixir processes (e.g., a GenServer per active lesson).

### **4.2 Syllabus**

*   A syllabus (structured as Modules containing Lessons) is needed for each topic.
*   Syllabi can be predefined or dynamically generated by Elixir services based on user topic input and assessment results.
*   Syllabi are stored in the **PostgreSQL** database (using Ecto).
*   The structure aligns with the database schema (adapted for Ecto).
*   An example syllabus follows (structure remains similar, week removed):
```(json)
{
  "topic": "Introduction to Quantum Computing",
  "level": "Beginner",
  "duration": "Self-paced", // Changed from weeks
  "learning_objectives": [
    "Understand the basic principles of quantum mechanics, including superposition and entanglement.",
    "Learn about qubits and their representation on the Bloch sphere.",
    "Become familiar with basic quantum gates and circuits.",
    "Understand the concept of measurement in quantum mechanics.",
    "Explore some basic applications of quantum computing."
  ],
  "modules": [
    {
      "title": "Introduction to Quantum Mechanics",
      "lessons": [
        { "title": "What *is* Superposition? (The Intuition)" },
        // ... other lessons ...
      ]
    },
    {
      "title": "Qubits and Quantum Gates",
      "lessons": [
        { "title": "The Bloch Sphere: A Deeper Dive" },
        // ... other lessons ...
      ]
    },
    // ... other modules ...
  ]
}
```


### **4.3 Lessons**

*   Each lesson is an interactive, conversational experience managed by a dedicated Elixir process (e.g., GenServer) per active user lesson.
*   The flow typically involves:
    *   Initial exposition or prompt from the AI (fetched/generated via the Elixir process).
    *   User interaction (asking questions, requesting exercises, submitting answers) potentially sent via Phoenix Channels/LiveView to the relevant process.
    *   Intent classification and state updates handled within the Elixir process.
    *   Dynamic generation of chat responses, exercises, or assessments by calling LLM APIs or using internal logic within the Elixir process.
    *   Evaluation of user answers with adaptive feedback, updating the process state.
*   Lesson state and conversation history are managed by the Elixir process and persisted to the PostgreSQL database (e.g., in `user_progress` and `conversation_history` tables), allowing users to resume lessons.

### **4.4 Bookmarking and Returning**

*   Lesson progress and state are automatically saved from the Elixir process to the database, allowing users to resume.
*   Manual bookmarking/favorites could be added.

### **4.5 Adaptive Difficulty**

*   The Elixir lesson process manages adaptive difficulty by:
    *   Evaluating user responses.
    *   Adjusting subsequent questions or explanations based on its internal state and performance tracking.
    *   Potentially prompting users to revisit foundational topics.

### **4.6 Progress Tracking / Gamification**

*   Visual progress bars (calculated from database data), badges, milestones.
*   Leaderboards.

### **4.7 Enterprise Use Cases**

*   Manager-defined syllabus, uploaded internal materials.
*   Enterprise dashboards for progress tracking.

### **4.8 Defining New Topics**

*   Users initiate learning on a new topic.
*   An Elixir service handles the onboarding assessment.
*   An Elixir service generates a personalized syllabus.

---

## **5\. Key Features & Functionality**

*   **Elixir/OTP-based Adaptive Learning Engine**: Manages onboarding, syllabus generation, and lesson interactions using concurrent, stateful Elixir processes.
*   **Syllabus Management**: Predefined or dynamically generated learning paths.
*   **Stateful, Concurrent Lesson Interactions**: Conversational lessons with context maintained within dedicated Elixir processes and persisted to the DB.
*   **On-Demand Exercises & Assessments**: AI generates exercises/quizzes within the lesson flow, orchestrated by Elixir services.
*   **AI-Powered Feedback**: Evaluation of user responses with adaptive feedback.
*   **Proprietary Content Integration**: Enterprise upload of internal materials.
*   **Bookmarking & Resuming**: Automatic progress and state saving.
*   **Progress & Gamification**: Badges, progress bars, leaderboards.
*   **Enterprise Admin Portal**: Syllabus assignment, analytics, user management.
*   **Short Video Content**: Uploaded, or AI-generated (*Future goal*).

---

## **6\. Non-Functional Requirements**

### **6.1 Performance**

*   Target fast response times, leveraging Phoenix LiveView for UI updates and efficient Elixir processes for backend logic. Provide loading indicators for LLM calls.
*   Concurrency: Designed for high concurrency using Elixir/OTP; target thousands of concurrent users.

### **6.2 Reliability**

*   High uptime target, leveraging OTP supervision trees for fault tolerance.
*   Graceful handling of LLM API outages or errors within Elixir processes.

### **6.3 Security and Privacy**

*   Standard web security practices (HTTPS, secure authentication, CSRF protection via Phoenix).
*   Encryption at rest (PostgreSQL features) and transit. GDPR/CCPA compliant.
*   Minimize personal data transfer to LLM APIs.

### **6.4 Scalability**

*   **Application Tier (Elixir/Phoenix):** Highly scalable horizontally due to the nature of the BEAM VM and OTP. Can handle a large number of concurrent connections/processes efficiently on multi-core systems.
*   **Database (PostgreSQL):** Standard database scaling techniques apply (read replicas, connection pooling via Ecto, potentially sharding if needed at extreme scale).
*   **LLMs:** Scaling depends on external LLM API limits.

### **6.5 Maintainability**

*   Modular design using Phoenix contexts and OTP principles.
*   Strong testing culture encouraged by the Elixir community (ExUnit).
*   Automated CI/CD pipeline.
*   Code formatting enforced (`mix format`). Improved compile-time checks with Elixir 1.17+.

### **6.6 Accessibility**

*   WCAG 2.1 AA compliance target for the Phoenix frontend templates/LiveView.

### **6.7 Analytics**

*   Usage and performance monitoring (e.g., Prometheus via `telemetry_metrics`, Grafana). BEAM VM introspection tools. Log aggregation.

---

## **7\. Technical Approach & Architecture (Target: Elixir/Phoenix)**

The application will be built using Elixir and the Phoenix framework, leveraging the BEAM VM for concurrency and fault tolerance.

### **Conceptual Flow**

```mermaid
graph LR
    A[User (Browser)] -- HTTP/WebSocket --> B(Phoenix Server);
    B -- Handles Request --> C{Phoenix Router/Controller/LiveView};
    C -- Interacts with --> D(Context Modules / Business Logic);
    D -- Uses --> E(Ecto / Database Repo);
    E -- Reads/Writes --> F[(PostgreSQL DB)];
    D -- Manages/Interacts with --> G(OTP Processes - GenServers for Lessons);
    G -- Calls --> H{LLM API};
    C -- Renders --> A;
```

### **Web Framework**

*   **Phoenix Framework (Elixir)**: Handles routing, controllers, channels, and potentially frontend rendering via **Phoenix LiveView**. LiveView allows rich, real-time user experiences with server-rendered HTML updated over WebSockets, minimizing client-side JavaScript.

### **AI & LLM Services**

*   **Orchestration**: Custom Elixir code leveraging **OTP principles** (GenServers, Supervisors, potentially state machine libraries) to manage stateful AI interactions (onboarding, syllabus, lessons). Each active lesson could be managed by its own GenServer process.
*   **LLMs**: Elixir processes interact with cloud-hosted LLMs (e.g., GPT models, Gemini) via HTTP client libraries (e.g., Tesla, Finch).

### **Data Storage**

*   **Database**: **PostgreSQL** (Recommended for scalability with Phoenix).
*   **Access**: Managed via **Ecto**, Elixir's database wrapper and query language. Ecto schemas define data structures and changesets handle validation and data manipulation.

### **Enterprise Admin Tools**

*   Implemented as standard Phoenix routes, controllers, and templates/LiveViews.

### **Analytics and Logging**

*   **Logging**: Standard Elixir Logger backend.
*   **Monitoring**: Integration with `Telemetry` library for metrics, potentially exporting to Prometheus/Grafana.

---

## **8\. Release Plan & Milestones**

*(Milestones adjusted for a rebuild)*

| Milestone | Description                                     | Date (approx.) |
| :-------- | :---------------------------------------------- | :------------- |
| PoC       | Basic lesson interaction via Elixir/OTP/LLM     | 2 Months       |
| MVP       | Core adaptive tutor features on Elixir/Phoenix  | 4-5 Months     |
| Beta      | Scaled usage, basic enterprise dashboards       | 7-9 Months     |
| v1.0      | Monetized enterprise deployments                | 12-15 Months   |

---

## **9\. Risks & Mitigations**

*   **Technical Risks**:
    *   **LLM Reliability/Cost**: Dependency on external LLM APIs. *Mitigation*: Caching responses, robust error handling in Elixir processes, monitoring costs, exploring alternative models.
    *   **Elixir Skillset**: Team may need training or time to become proficient in Elixir/OTP/Phoenix. *Mitigation*: Allocate time for learning, leverage community resources, start with simpler features.
    *   **AI Orchestration Complexity**: Building robust state management for AI interactions requires careful OTP design. *Mitigation*: Design incrementally, use established OTP patterns, consider state machine libraries if helpful.
*   **Market Risks**:
    *   **Initial Adoption**: Gaining traction. *Mitigation*: Focus on unique interactive/adaptive features, offer a compelling free tier, build a community.

---

## **10\. KPIs & Success Metrics**

*(Remain the same)*

*   **User Retention & Engagement**: DAU/MAU, session duration, lesson completion rates.
*   **Learning Progress**: Mastery rates, syllabus completions, user feedback.
*   **Enterprise Adoption**: Paying enterprise accounts, revenue generated.